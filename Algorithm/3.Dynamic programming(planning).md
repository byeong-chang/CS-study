# chap3. Dynamic programming(planning)

- 작은 문제가 반복되는 경우에 작은문제를 계산하여 한번 계산한 값을 저장하고 검색 후 재사용하는 방식. = recomputing 대신 look up table 만들기.

### fibonacci number

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/04fcfafd-9bac-418d-a04d-248b7fd58e37/Untitled.png)

### DP의 핵심 스텝

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/359ae798-727e-4f5c-b893-58bb3ffbcdba/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e798a008-1551-4d26-8caa-4796f075f9a9/Untitled.png)

DP는 schedule을 사용하여 문제를 효율적으로 풀지만 메모리를 추가로 사용하고

divide and conquer는 문제를 blindly(무턱대고)풀며, 스케줄링과 planning이 없다. - 겹치는 계산이 없을때 쓰면 좋음.

### Compute binomial coefficient=이항계수 문제

계속 이전 항끼리의 합을 구하는 방식이라 겹치는(over lapping)부분과 반복되는 계산이 많다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/df247b69-e016-444b-9e43-44c4ee0998f9/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f9ff6c83-6936-4ab8-a289-bbdf8f7df36f/Untitled.png)

basic operation = addition operation = B[r][c] = B[r-1][c-1] + B[r-1][c]

### shortest path problem  - Floyd’s algorithm

D(0) = 초기 값 graph를 만든 후,

D(1) = 1을 거쳐가는 경우를 모두 만들어 이전 dimension(D(0))의 값과 비교를 한다. 그렇게 해서 더 작은걸 D(1)에 저장

D(2) = D(1)의 값과 2를 거쳐 가는 경우를 비교저장

D(3) = 3을 거치는

D(4) = 4를 거치는 

이러한 과정을 통해 모든 경로에 대한 가장 짧은 거리 table을 저장한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/086e5d8b-26b9-4471-b87b-05833219dffe/Untitled.png)

time complexity = T(n) = nxnxn = n^3

shortest 걸이를 저장하는 D(n)외에도 경로를 저장하는 P(n)을 만들어 저장하면 어느 길을 통해 오는지 파악가능.

 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/31750f74-7ada-486b-8508-5efc018c8c6b/Untitled.png)

### optimal binary search Tree

각 node마다 probability를 부여하고 모든 노드에 대해 

node에 가는시간 x probability를 계산해 더한 값이 가장 작은 BST를 뜻함.

모든 BST경우를 구하는데 걸리는 시간

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6b9932a0-33ea-490f-a8fc-d2a343b4b201/Untitled.png)

DP를 사용하여 구하면 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ef060b2-3e16-429e-a28e-c6d38c3fa120/Untitled.png)

하나 구하는 일반화공식

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d32142b5-2369-4d5d-8beb-54fb172c55da/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/47180bee-ef98-4f9b-a718-581a05817f6f/Untitled.png)

dimension을 넓혀가면서(i와 j의 차이를 넓혀가며) 표를 구해 저장하고, 마지맊까지 계산하여 골에 도달하면 그 값이 BST값인것.

계산 요령

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/30700118-37e0-4bec-a375-cd88632ecd8e/Untitled.png)
