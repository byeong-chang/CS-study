# chap5 Backtracking Algorithm design approach

- 해가 될 가능성이 있는지 promising을 확인한 후 필요없으면 가지치기 prune을 한다.

1. depth- first-search backtracking 푸는법
  1. tree형태로 visualize한다

2. branch를 제거하는 메커니즘을 설정한다.

3. 조건에 따라 단일 leaf node에 도달하거나 여러개의 leaf node에 도달 할 것이다. 이후 조건에 따라 이중 하나를 고르거나 하겠지.

### Queens problem  = nxn 체스판에 n개의 퀸을 겹치지 않게 올리는 방법

n^4 경우의 수가 있으며 유망하지 않은 node와 그 자식은 거르기 = non optimization

n=4일때 예제

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4fb0217b-16eb-4645-9c50-8142c1596a34/Untitled.png)

4x4 queens 문제를 backtracking depth first search로 풀면 27번 걸리지면

그냥 depth first search로 풀면 가지치기를 안하기 떄문에 155번 걸린다.

1.그냥 dfs time complexity = n^n+n^n-1 + n^n-2+…+n^1+1

2.좌우 앞뒤에 퀸이 없다는 제약조건에서의 dfs = 1+n+n(n-1)+..n! 

3.back tracking timecomplexity = 비약적 감소

이렇게 같은 문제임에도 각각 인스턴스별로 다른 복잡도를 가지면 NP문제임

Ex2) sum of subset 문제= non optimization

숫자 던져주고 ex 3 5 6 7을 주고 , 목표치 ex15를 찾아내는 문제. 

Ex3) 0-1 Knapsack -optimization problem

optimization problem don’t know the solution until the search is over

T(n) = 2^n

Greedy는 구하지못했으니 배제하고 , DP의 knapsack과 비교했을때 time complexity는 같기에 theoritical 분석은 안된다. backtracking knapsack문제풀이는 input data에 따라 버려지는 가지수가 정해지기에 많이 다를것이다.
